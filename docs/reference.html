<!DOCTYPE html>

<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1"
          >

    <title>Parenscript Reference Manual</title>

    <style type="text/css">
      body {
        max-width: 70ex;
        margin: auto;
      }
      dl {
        margin-left: 2em;
      }
      dt {
        margin-top: 0.5ex;
        border: 1px solid #d5d5d5;
        background: #f9f9f9;
      }
      dd {
        margin-top: 0.5ex;
      }
      p {
        margin-left: 1em;
      }
      pre {
        margin: 0;
      }
      samp {
        color: #60a;
        font-weight: bolder;
      }
    </style>
  </head>

  <body>
    <h1 style="text-align:center;">Parenscript Reference Manual</h1>

    <p>
      Copyright 2005 Marco Baringer.<br/>
      Copyright 2006 Henrik Hjelte.<br/>
      Copyright 2009-2012, 2018-2020 Vladimir Sedach.<br/>

      Permission is granted to copy, distribute and/or modify this
      document under the terms of the GNU Free Documentation License,
      Version 1.3 or any later version published by the Free Software
      Foundation; with no Invariant Sections, no Front-Cover Texts,
      and no Back-Cover Texts. A copy of the license can be
      found <a href="https://www.gnu.org/licenses/fdl.html">on the
      GNU website</a>.
    </p>

    <h2>Table of Contents</h2>

    <ol>
      <li><a href="#section-notation">Notation used in this manual</a></li>
      <li><a href="#section-ps-compiler">The Parenscript compiler</a></li>
      <li><a href="#section-symbolconv">Symbol conversion</a></li>
      <li><a href="#section-namespace">The Parenscript namespace system</a>
        <ul>
          <li><a href="#section-obfuscation">Identifier obfuscation</a></li>
          <li><a href="#section-minification">Minification</a></li>
        </ul>
      </li>
      <li><a href="#reserved-symbols">Reserved symbols</a></li>
      <li><a href="#section-statements-expressions">Statements, expressions, and return</a></li>
      <li><a href="#section-types">Types and type predicates</a></li>
      <li><a href="#section-literals">Literals</a>
        <ul>
          <li><a href="#ssection-numbers">Numbers</a></li>
          <li><a href="#ssection-strings-chars">Strings and characters</a></li>
          <li><a href="#ssection-regex">Regular expressions</a></li>
          <li><a href="#ssection-booleans">Booleans and undefined</a></li>
        </ul>
      </li>
      <li><a href="#section-objects">Objects</a></li>
      <li><a href="#section-arrays">Arrays</a></li>
      <li><a href="#section-arithmetic">Arithmetic and boolean operators</a></li>
      <li><a href="#section-math">Mathematical functions and constants</a></li>
      <li><a href="#section-blocks">Blocks</a></li>
      <li><a href="#section-functions">Functions and multiple values</a></li>
      <li><a href="#section-control-transfer">Control transfer and exceptions</a></li>
      <li><a href="#section-conditionals">Conditionals</a></li>
      <li><a href="#section-variables">Variable binding and declaration</a></li>
      <li><a href="#section-assignment">Assignment</a></li>
      <li><a href="#section-iteration">Iteration</a></li>
      <li><a href="#section-macros">Macros</a>
        <ul>
          <li><a href="#ssection-defining-macros">Defining macros</a></li>
          <li><a href="#ssection-symbol-macros">Symbol macros</a></li>
          <li><a href="#ssection-gensym">Gensym</a></li>
        </ul>
      </li>
      <li><a href="#section-utilities">Utilities</a>
        <ul>
          <li><a href="#ssection-dom">DOM</a></li>
          <li><a href="#ssection-html-gen">HTML generation</a></li>
        </ul>
      </li>
      <li><a href="#section-runtime-library">Run-time library</a></li>
      <li><a href="#section-slime-integration">SLIME integration</a></li>
    </ol>

    <h2 id="section-notation">Notation used in this manual</h2>
    <ul>
      <li><code>Lisp form</code></li>
      <li><var>Lisp variable</var></li>
      <li>(<code>lisp-function-name</code> <var>lisp-function-argument</var>)</li>
      <li><samp>JavaScript code</samp></li>
      <li><dl><dt>Term</dt><dd>Definition of term</dd></dl></li>
      <li><dl><dt><code>(Lisp forms)</code></dt><dd><samp>Lisp forms compiled to JavaScript;</samp></dd></dl></li>
    </ul>

    <h2 id="section-ps-compiler">The Parenscript compiler</h2>

    <ul>
      <li>(<code id="ps">PS</code> &amp;body <var>body</var>)</li>
      <li>(<code id="ps-to-stream">PS-TO-STREAM</code> <var>stream</var> &amp;body <var>body</var>)</li>
      <li>(<code id="ps*">PS*</code> &amp;rest <var>body</var>)</li>
      <li>(<code id="ps-doc">PS-DOC</code> &amp;body <var>body</var>)</li>
      <li>(<code id="ps-doc*">PS-DOC*</code> &amp;body <var>body</var>)</li>
      <li>(<code id="ps-inline">PS-INLINE</code> <var>form</var> &amp;optional <var>*JS-STRING-DELIMITER*</var>)</li>
      <li>(<code id="ps-inline*">PS-INLINE*</code> <var>form</var> &amp;optional <var>*JS-STRING-DELIMITER*</var>)</li>
      <li>(<code id="ps-compile-stream">PS-COMPILE-STREAM</code> <var>stream</var>)</li>
      <li>(<code id="ps-compile-file">PS-COMPILE-FILE</code> <var>file</var>)</li>
      <li>(<code id="lisp">LISP</code> <var>lisp-form</var>)</li>
      <li>(<code id="symbol-to-js-string">SYMBOL-TO-JS-STRING</code> <var>symbol</var>)</li>

      <li><var id="*js-target-version*">*JS-TARGET-VERSION*</var></li>
      <li><var id="*parenscript-stream*">*PARENSCRIPT-STREAM*</var></li>
      <li><var id="*js-string-delimiter*">*JS-STRING-DELIMITER*</var></li>
      <li><var id="*js-inline-string-delimiter*">*JS-INLINE-STRING-DELIMITER*</var></li>
      <li><var id="*ps-read-function*">*PS-READ-FUNCTION*</var></li>
      <li><var id="*version*">*VERSION*</var></li>
      <li><var id="*defined-operators*">*DEFINED-OPERATORS*</var></li>
    </ul>

    <dl>
      <dt><var>body</var></dt> <dd>implicit <code>PROGN</code></dd>
    </dl>

    <p>The difference between the regular and <code>*</code> versions
      of the Parenscript compiler forms is roughly the difference
      between <code>COMPILE</code>
      and <code>EVAL</code>. The <code>*</code> forms are functions
      that do all compilation when they are evaluated, while the
      regular forms are macros that do almost all (except for the use
      of the <code>LISP</code> special form, see below) compilation at
      macro-expansion time.</p>

    <p><code>PS</code> and <code>PS*</code> are the main interfaces to
      the Parenscript compiler. They come with <code>PS-DOC</code>
      and <code>PS-DOC*</code> counterparts which compile the given
      code
      with <a href="#*ps-gensym-counter*"><var>*PS-GENSYM-COUNTER*</var></a>
      bound to <kbd>0</kbd>, and are useful for writing automated
      tests.</p>

    <p>By default, Parenscript writes output to a string. You can
      output directly to a stream in one of two ways: either by
      using <code>PS-TO-STREAM</code> instead of <code>PS</code>, or by
      binding <var>*PARENSCRIPT-STREAM*</var> before
      calling <code>PS*</code>.</p>

    <p><code>PS-INLINE</code> and <code>PS-INLINE*</code> take a single
      Parenscript form and output a string starting
      with <samp>javascript:</samp> that can be used in HTML node
      attributes. As well, they provide an argument to bind the value of
      <var>*JS-STRING-DELIMITER*</var> to control the value of the
      JavaScript string escape character to be compatible with
      whatever the HTML generation mechanism is used (for example, if
      HTML strings are delimited using <code>#\'</code>,
      using <code>#\&quot;</code> will avoid conflicts without
      requiring the output JavaScript code to be escaped). By default
      the value is taken
      from <var>*JS-INLINE-STRING-DELIMITER*</var>.</p>

    <p>Parenscript code can be compiled from a stream or file
      via <code>PS-COMPILE-STREAM</code>
      and <code>PS-COMPILE-FILE</code>, respectively. The special
      variable <var>*PS-READ-FUNCTION*</var> is bound to the function
      used to read the forms from the file/stream (<code>READ</code> by
      default), and can be used to provide completely customizable
      syntax for Parenscript files.</p>

    <p>Parenscript can also call out to arbitrary Common Lisp code at
      <em>output time</em> (that is, every time an expression containing
      a call to the Parenscript compiler is evaluated, compared
      to <em>compile time</em>, where the effect is accomplished using
      macros) using the special form <code>LISP</code>. The form
      provided to <code>LISP</code> is evaluated, and its result is
      compiled as though it were Parenscript code. For <code>PS</code>
      and <code>PS-INLINE</code>, the Parenscript output code is
      generated at macro-expansion time, and the <code>LISP</code>
      statements are inserted inline into the output and have access
      to the enclosing Common Lisp lexical
      environment. <code>PS*</code> and <code>PS1*</code> evaluate the
      <code>LISP</code> forms using <code>EVAL</code>, providing them
      access to the current dynamic environment only
      (using <code>LISP</code> when calling the <code>*</code> forms
      is not strictly necessary, as the values can be inserted inline
      into code).</p>

    <p><var>*JS-TARGET-VERSION*</var> (<kbd>"1.3"</kbd> by default)
      controls which version of JavaScript that Parenscript
      targets. For newer versions of JS, some Parenscript special
      forms may compile to more concise and/or efficient expressions
      that are not present in earlier versions of JavaScript.</p>

    <p><code>SYMBOL-TO-JS-STRING</code> is the Parenscript function
      responsible for translating Common Lisp symbols to JavaScript
      identifiers (see the section
      on <a href="#section-symbolconv">symbol conversion</a> for the
      translation rules). It is helpful for writing libraries or other
      pieces of code that will interface with Parenscript-generated
      JavaScript.</p>

    <p>Newer versions of Parenscript may implement Common Lisp special
    forms, functions or macros that were left unimplemented by earlier
    versions. This can cause problems if your code provides
    implementations for those forms itself. To help deal with
    this, <var>*DEFINED-OPERATORS*</var> provides a list of special
    forms, macros, and symbol macros defined by Parenscript
    itself. <var>*VERSION*</var> is bound to the current release
    version number of Parenscript.</p>

    <h2 id="section-symbolconv">Symbol conversion</h2>

    <p>Parenscript supports output for both case-sensitive and
    case-insensitive symbols. By default the Lisp reader up-cases all
    symbols. By setting <code>readtable-case</code>
    to <a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/23_ab.htm"><code>:invert</code></a>
    (you can use
    the <a href="https://common-lisp.net/project/named-readtables/">named-readtables</a>
    library to make this more convenient) symbol case is preserved,
    and Parenscript will output mixed-case symbols
    (like <samp>encodeURIComponent</samp>) correctly.</p>

    <p>Lisp symbols (other than keywords) that are all uppercase or
      contain special characters are converted to JavaScript
      identifiers by following a few simple rules. Special
      characters <code>!, ?, #, @, %, /, *</code> and <code>+</code>
      get replaced by their written-out equivalents "bang", "what",
      "hash", "at", "percent", "slash", "start" and "plus"
      respectively. The <code>$</code> character is untouched.</p>

    <dl>
      <dt><code>!?#@%</code></dt>
      <dd><samp>bangwhathashatpercent;</samp></dd>
    </dl>

    <p>The <code>-</code> is an indication that the following
      character should be converted to uppercase.</p>

    <dl>
      <dt><code>bla-foo-bar</code></dt>
      <dd><samp>blaFooBar;</samp></dd>
    </dl>

    <p>JavaScript identifiers that begin with an uppercase letter can
      be obtained with a leading <code>-</code> or <code>*</code>.</p>

    <dl>
      <dt><code>*array</code></dt>
      <dd><samp>Array;</samp></dd>
    </dl>

    <p>A symbol starting and ending with <code>+</code>
      or <code>*</code> is converted to all uppercase, to signify that
      this is a constant or a global variable.</p>

    <dl>
      <dt><code>*global-array*</code></dt>
      <dd><samp>GLOBALARRAY;</samp></dd>
    </dl>

    <p>Keywords are not translated to JavaScript identifiers, but are
      printed in lower case without any character substitution as
      strings. This is done because strings are the closest equivalent
      to Common Lisp keywords (being self-evaluating objects in
      JavaScript), and to permit keywords to be used for identifying
      various symbols (for example, as tokens in a parser).</p>

    <dl>
      <dt><code>:+</code></dt>
      <dd><samp>'+';</samp></dd>

      <dt><code>:foo-Bar</code></dt>
      <dd><samp>'foo-bar';</samp></dd>
    </dl>

    <h2 id="section-namespace">The Parenscript namespace system</h2>
    <ul>
      <li>
        (<code id="in-package">in-package</code> <var>package-designator</var>)
      </li>
      <li>
        (<code id="use-package">use-package</code> <var>package-designator</var>)
      </li>
      <li>
        (setf (<code id="ps-package-prefix">PS-PACKAGE-PREFIX</code> <var>package-designator</var>) <var>string</var>)
      </li>
    </ul>

    <p>
      Although JavaScript does not offer namespacing or a package
      system, Parenscript does provide a namespace mechanism for
      generated JavaScript by integrating with the Common Lisp package
      system. Since Parenscript code is normally read in by the Lisp
      reader, all symbols (except for uninterned ones, i.e. - those
      specified with the <code>#:</code> reader macro) have a Lisp
      package. By default, no packages are prefixed. You can specify
      that symbols in a particular package receive a prefix when
      translated to JavaScript with the
      <var>PS-PACKAGE-PREFIX</var> place.
    </p>

    <dl>
      <dt>
        <pre><code>(defpackage "PS-REF.MY-LIBRARY"
  (:use "PARENSCRIPT"))

(setf (ps-package-prefix "PS-REF.MY-LIBRARY") "my_library_")

(ps (defun ps-ref.my-library::library-function (x y)
      (+ x y)))</code></pre>
      </dt>

      <dd>
        <pre><samp>function my_library_libraryFunction(x, y) {
    return x + y;
};</samp></pre>
      </dd>
    </dl>

    <p>
      Parenscript provides <code>IN-PACKAGE</code>
      and <code>USE-PACKAGE</code> special forms, primarily useful
      with <a href="#ps-compile-file"><code>PS-COMPILE-FILE</code></a>
      and <a href="#ps-compile-stream"><code>PS-COMPILE-STREAM</code></a>.
    </p>

    <h3 id="section-obfuscation">Identifier obfuscation</h3>
    <ul>
      <li>
        (<code id="obfuscate-package">OBFUSCATE-PACKAGE</code> <var>package-designator</var> &amp;optional <var>symbol-map</var>)
      </li>
      <li>
        (<code id="unobfuscate-package">UNOBFUSCATE-PACKAGE</code> <var>package-designator</var>)
      </li>
    </ul>

    <p>Similar to the namespace mechanism, Parenscript provides a
      facility to generate obfuscated identifiers in specified CL
      packages. The function <code>OBFUSCATE-PACKAGE</code> may
      optionally be passed a closure that maps symbols to their
      obfuscated counterparts. By default, the mapping is done
      using <code><a href="#ps-gensym">PS-GENSYM</a></code>.</p>

    <dl>
      <dt>
        <pre><code>(defpackage "PS-REF.OBFUSCATE-ME")

(obfuscate-package "PS-REF.OBFUSCATE-ME"
  (let ((code-pt-counter #x8CF6)
        (symbol-map (make-hash-table)))
    (lambda (symbol)
      (or (gethash symbol symbol-map)
          (setf (gethash symbol symbol-map)
                (make-symbol (string (code-char (incf code-pt-counter)))))))))

(defun ps-ref.obfuscate-me::a-function (a b ps-ref.obfuscate-me::foo)
  (+ a (ps-ref.my-library::library-function b ps-ref.obfuscate-me::foo)))</code></pre>
      </dt>

      <dd>
<pre><samp>function 賷(a, b, 賸) {
    return a + libraryFunction(b, 賸);
};</samp></pre>
      </dd>
    </dl>

    <p>The obfuscation and namespace facilities can be used on packages
      at the same time.</p>

    <p>Since Parenscript doesn't know anything about the DOM or other
    JavaScript libraries, library function and property names might be
    inadvertently obfuscated. To help prevent that, Parenscript comes
    with
    the <code>ps-dom1-symbols</code>, <code>ps-dom2-symbols</code>, <code>ps-window-wd-symbols</code>, <code>ps-dom-nonstandard-symbols</code>
    and <code>ps-dhtml-symbols</code> symbol packages that define
    various DOM property and function identifiers as exported symbols
    (in both case-sensitive and insensitive variants), which you can
    import into your packages to help prevent symbols
    like <code>pageXOffset</code> from being
    obfuscated. The <code>ps-dhtml-symbols</code> package contains the
    broadest range of symbols and is most generally useful.</p>

    <p>If you use obfuscation and external JavaScript libraries, you
    can use the same technique to define your own packages with
    symbols that will not be obfuscated.</p>

    <h3 id="section-minification">Minification</h3>
    <ul>
      <li><var id="*ps-print-pretty*">*PS-PRINT-PRETTY*</var></li>
      <li><var id="*indent-num-spaces*">*INDENT-NUM-SPACES*</var></li>
    </ul>

    <p><var>*PS-PRINT-PRETTY*</var> and <var>*INDENT-NUM-SPACES*</var>
      control whether the resulting JavaScript code is pretty-printed,
      and if so, how many spaces go into each indent level,
      respectively. By default the code is pretty-printed
      with <kbd>4</kbd> spaces per indent level.</p>

    <p>Setting <var>*PS-PRINT-PRETTY*</var> to nil and turning
    on <a href="#section-obfuscation">obfuscation</a> will minify the
    generated JavaScript code.</p>

    <h2 id="reserved-symbols">Reserved symbols</h2>

    <p>The following symbols are reserved in Parenscript, and should not
      be used as variable names.</p>

    <code>
      ! ~ ++ -- * / % + - &lt;&lt; &gt;&gt; &gt;&gt;&gt; &lt; &gt;
      &lt;= &gt;= == != === !== & ^ | && || *= /= %= += -= &lt;&lt;=
      &gt;&gt;= &gt;&gt;&gt;= &= ^= |= 1- 1+ @ ABSTRACT AND AREF ARRAY
      BOOLEAN BREAK BYTE CASE CATCH CHAR CLASS COMMA CONST CONTINUE
      PS-CREATE DEBUGGER DECF DEFAULT DEFUN DEFVAR DELETE DO DO* DOEACH
      DOLIST DOTIMES DOUBLE ELSE ENUM EQL EXPORT EXTENDS F FALSE FINAL
      FINALLY FLOAT FLOOR FOR FOR-IN FUNCTION GOTO IF IMPLEMENTS
      IMPORT IN INCF INSTANCEOF INT INTERFACE JS LABELED-FOR LAMBDA
      LET LET* LISP LIST LONG MAKE-ARRAY NATIVE NEW NIL NOT OR PACKAGE
      PRIVATE PROGN PROTECTED PUBLIC RANDOM REGEX RETURN SETF SHORT
      GETPROP STATIC SUPER SWITCH SYMBOL-MACROLET SYNCHRONIZED T THIS
      THROW THROWS TRANSIENT TRY TYPEOF UNDEFINED UNLESS VAR VOID
      VOLATILE WHEN WHILE WITH WITH-SLOTS
    </code>

    <h2 id="section-statements-expressions">Statements, expressions, and return</h2>

    <p>
      In contrast to Lisp, where everything is an expression,
      JavaScript makes an arbitrary distinction between expressions,
      which yield a value and can be nested in other expressions, and
      statements, which have no value and cannot occur in expressions.
    </p>

    <p>
      Some Parenscript special forms compile to expressions, while
      others can only compile to statements. Certain Parenscript
      forms, like <code>IF</code> and <code>PROGN</code>, generate
      different JavaScript depending on if they are used in an
      expression context or a statement context. In such cases,
      Parenscript tries to generate statement code if possible to
      increase readability, only falling back to the expression code
      if it is necessary.
    </p>

    <dl>
      <dt>
        <code>(+ i (if x (foo) (bar)))</code>
      </dt>

      <dd>
        <samp>i + (x ? foo() : bar());</samp>
      </dd>

      <dt>
        <code>(if x (foo) (bar))</code>
      </dt>

      <dd>
<pre><samp>if (x) {
    foo();
} else {
    bar();
};</samp></pre>
      </dd>
      </dl>

    <p>
      One important feature found in Lisp but absent from JavaScript
      is implicit return from functions. Parenscript automatically
      provides implicit return for JavaScript statements and
      expressions:
    </p>

    <dl>
      <dt>
        <pre><code>(defun foo (x)
  (1+ x))</code></pre>
      </dt>

      <dd>
        <pre><samp>function foo(x) {
    return x + 1;
};</samp></pre>
      </dd>

      <dt>
        <pre><code>(lambda (x)
  (case x
    (1 (loop repeat 3 do (alert "foo")))
    (:bar (alert "bar"))
    (otherwise 4)))</code></pre>
      </dt>

      <dd>
        <pre><samp>function (x) {
    switch (x) {
    case 1:
        for (var _js1 = 0; _js1 < 3; _js1 += 1) {
            alert('foo');
        };
        return null;
    case 'bar':
        return alert('bar');
    default:
        return 4;
    };
};</samp></pre>
      </dd>
    </dl>

    <p>
      Parenscript generates code that works around the JavaScript
      expression-statement dichotomy in an unobtrusive way:
    </p>

    <dl>
      <dt>
        <pre><code>(+ 1 (dotimes (x 3) (if (= x 2) (return (+ x x)))))</code></pre>
      </dt>

      <dd>
        <pre><samp>(function () {
    for (var x = 0; x < 3; x += 1) {
        if (x === 2) {
            return x + x;
        };
    };
})() + 1;</samp></pre>
      </dd>
    </dl>

    <h2 id="section-types">Types and type predicates</h2>
    <ul>
      <li>(<code id="typeof">TYPEOF</code> <var>object</var>)</li>
      <li>(<code id="instanceof">INSTANCEOF</code> <var>object</var> <var>type</var>)</li>
      <li>(<code id="null">NULL</code> <var>object</var>)</li>
      <li>(<code id="undefined_1">UNDEFINED</code> <var>object</var>)</li>
      <li>(<code id="defined">DEFINED</code> <var>object</var>)</li>
      <li>(<code id="stringp">STRINGP</code> <var>object</var>)</li>
      <li>(<code id="numberp">NUMBERP</code> <var>object</var>)</li>
      <li>(<code id="functionp">FUNCTIONP</code> <var>object</var>)</li>
      <li>(<code id="objectp">OBJECTP</code> <var>object</var>)</li>
    </ul>

    <dl>
      <dt><var>object</var></dt> <dd>an expression yielding an object</dd>
      <dt><var>type</var></dt> <dd>a type designator</dd>
    </dl>

    <p>Parenscript is based around the JavaScript type system, and
    does not introduce any new types or objects, nor does it attempt
    to provide a Common Lisp-like interface to the type system.</p>

    <h2 id="section-literals">Literals</h2>

    <h3 id="ssection-numbers">Numbers</h3>

    <p>Parenscript prints all integer literals as integers, and floats
    and rationals as floats, in base 10.</p>

    <dl>
      <dt><code>1</code></dt>
      <dd><samp>1;</samp></dd>

      <dt><code>123.123</code></dt>
      <dd><samp>123.123;</samp></dd>

      <dt><code>3/4</code></dt>
      <dd><samp>0.75;</samp></dd>

      <dt><code>#x10</code></dt>
      <dd><samp>16;</samp></dd>
    </dl>

    <h3 id="ssection-strings-chars">Strings and characters</h3>

    <p>Lisp strings are converted to JavaScript strings.</p>

    <dl>
      <dt><code>"foobar"</code></dt>
      <dd><samp>'foobar';</samp></dd>
    </dl>

    <p>Parenscript makes no effort to interpolate C-style escape
    strings. Rather, non-printable characters in Lisp strings are
    output using escape sequences:</p>

    <dl>
      <dt><code>#\Tab</code></dt>
      <dd><samp>'\t';</samp></dd>

      <dt><code>"\\n"</code></dt>
      <dd><samp>'\\n';</samp></dd>
    </dl>

    <h3 id="ssection-regex">Regular expressions</h3>
    <ul>
      <li>(<code id="regex">REGEX</code> <var>regex</var>)</li>
    </ul>

    <dl>
      <dt><var>regex</var></dt> <dd>a string</dd>
    </dl>

    <p>Regular expressions can be created by using
      the <code>REGEX</code> form. If the argument does not start with
      <code>/</code>, it is surrounded by <code>/</code>, otherwise it
      is left as it is.</p>

    <dl>
      <dt><code>(regex "foobar")</code></dt>
      <dd><samp>/foobar/;</samp></dd>

      <dt><code>(regex "/foobar/i")</code></dt>
      <dd><samp>/foobar/i;</samp></dd>
    </dl>

    <p><a href="https://edicl.github.io/cl-interpol/">CL-INTERPOL</a> is
      convenient for writing regular expressions:</p>

    <dl>
      <dt><code>(regex #?r"/([^\s]+)foobar/i")</code></dt>
      <dd><samp>/([^\s]+)foobar/i;</samp></dd>
    </dl>

    <h3 id="ssection-booleans">Booleans and undefined</h3>
    <ul>
      <li><code id="t">T</code></li>
      <li><code id="f">F</code></li>
      <li><code id="false">FALSE</code></li>
      <li><code id="nil">NIL</code></li>
      <li><code id="undefined">UNDEFINED</code></li>
    </ul>

    <p><code>T</code> and <code>FALSE</code> (or <code>F</code>) are
      converted to their JavaScript boolean
      equivalents <samp>true</samp> and <samp>false</samp>.</p>

    <p><code>NIL</code> is converted to the JavaScript keyword
      <samp>null</samp>.</p>

    <p><code>UNDEFINED</code> is converted to the JavaScript global
    variable <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Properties/undefined"><samp>undefined</samp></a>.</p>

    <h2 id="section-objects">Objects</h2>
    <ul>
      <li>(<code id="new">NEW</code> <var>constructor</var>)</li>
      <li>(<code id="ps-create">PS-CREATE</code> {<var>name</var> <var>value</var>}*)</li>
      <li>(<code id="getprop">GETPROP</code> <var>object</var> {<var>slot-specifier</var>}*)</li>
      <li>(<code id="@">@</code> {<var>slot-specifier</var>}*)</li>
      <li>(<code id="chain">CHAIN</code> {<var>slot-specifier</var> | <var>function-call</var>}*)</li>
      <li>(<code id="with-slots">WITH-SLOTS</code> ({<var>slot-name</var>}*) <var>object</var> <var>body</var>)</li>
      <li>(<code id="delete">DELETE</code> <var>object</var>)</li>
    </ul>

    <dl>
      <dt><var>constructor</var></dt> <dd>a function call to an object constructor</dd>
      <dt><var>name</var></dt> <dd>symbol, string or keyword</dd>
      <dt><var>value</var></dt> <dd>an expression</dd>
      <dt><var>object</var></dt> <dd>an expression yielding an object</dd>
      <dt><var>slot-specifier</var></dt> <dd>a quoted symbol, a string, a number, or an expression yielding a string or number</dd>
      <dt><var>body</var></dt> <dd>implicit <code>PROGN</code></dd>
    </dl>

    <p>The <code>NEW</code> operator maps to JavaScript like:</p>

    <dl>
      <dt><code>(new (-Person age shoe-size))</code></dt>
      <dd><samp>new Person(age, shoeSize);</samp></dd>
    </dl>

    <p>Object literals are created
      with <code>PS-CREATE</code>. <code>PS-CREATE</code> takes a property
      list of property names and values.</p>

    <dl>
      <dt>
        <code>(ps-create foo "bar" :blorg 1)</code>
      </dt>

      <dd>
        <samp>{ foo : 'bar', 'blorg' : 1 };</samp>
      </dd>

      <dt>
        <pre><code>(ps-create foo "hihi"
        blorg (array 1 2 3)
        another-object (ps-create :schtrunz 1))</code></pre>
      </dt>

      <dd>
<pre><samp>{ foo : 'hihi',
     blorg : [ 1, 2, 3 ],
     anotherObject : { 'schtrunz' : 1 } };</samp></pre>
      </dd>
    </dl>

    <p>Object properties can be accessed using
      <code>GETPROP</code>, which takes an object and a list of
      properties.</p>

    <dl>
      <dt><code>(getprop obj 'foo)</code></dt>
      <dd><samp>obj.foo;</samp></dd>

      <dt><code>(getprop obj foo)</code></dt>
      <dd><samp>obj[foo];</samp></dd>

      <dt><code>(getprop element i 'child-node 0 'node-value)</code></dt>
      <dd><samp>element[i].childNode[0].nodeValue;</samp></dd>
    </dl>

    <p>The convenience macro <code>@</code> quotes all its given
    symbol slot-specifiers to save typing:</p>

    <dl>
      <dt><code>(@ an-object foo bar)</code></dt>
      <dd><samp>anObject.foo.bar;</samp></dd>

      <dt><code>(@ foo bar child-node 0 node-value)</code></dt>
      <dd><samp>foo.bar.childNode[0].nodeValue;</samp></dd>
    </dl>

    <p><code>CHAIN</code> can be used to conveniently chain together
    accessors and function calls:</p>

    <dl>
      <dt><code>(chain foo (bar x y) 0 baz)</code></dt>
      <dd><samp>foo.bar(x, y)[0].baz;</samp></dd>
    </dl>

    <p><code>WITH-SLOTS</code> can be used to bind the given
      slot-names to a symbol macro that will expand into
      a <code>GETPROP</code> form at expansion time:</p>

    <dl>
      <dt>
<pre><code>(with-slots (a b c) this
  (+ a b c))</code></pre>
      </dt>

      <dd>
        <samp>this.a + this.b + this.c;</samp>
      </dd>
    </dl>

    <h2 id="section-arrays">Arrays</h2>
    <ul>
      <li>(<code id="array">ARRAY</code> {<var>value</var>}*)</li>
      <li>(<code id="list">LIST</code> {<var>value</var>}*)</li>
      <li>(<code id="[]">[]</code> {<var>value</var>}*)</li>
      <li>(<code id="make-array">MAKE-ARRAY</code> {<var>value</var>}*)</li>
      <li>(<code id="length">LENGTH</code> <var>array</var>)</li>
      <li>(<code id="aref">AREF</code> <var>array</var> <var>index</var>)</li>
      <li>(<code id="elt">ELT</code> <var>array</var> <var>index</var>)</li>
      <li>(<code id="destructuring-bind">DESTRUCTURING-BIND</code> <var>bindings</var> <var>array</var> <var>body</var>)</li>
      <li>(<code id="concatenate">CONCATENATE 'STRING</code> {<var>value</var>}*)</li>
      <li>(<code id="append">APPEND</code> {<var>value</var>}*)</li>
    </ul>

    <dl>
      <dt><var>value</var></dt> <dd>an expression</dd>
      <dt><var>array</var></dt> <dd>an expression</dd>
      <dt><var>index</var></dt> <dd>an expression</dd>
    </dl>

    <p>Array literals can be created using the <code>ARRAY</code>
      or <code>LIST</code> forms.</p>

    <dl>
      <dt><code>(array)</code></dt>
      <dd><samp>[];</samp></dd>

      <dt><code>(array 1 2 3)</code></dt>
      <dd><samp>[1, 2, 3];</samp></dd>

      <dt><code>(list (foo) (bar) 3)</code></dt>
      <dd><samp>[foo(), bar(), 3];</samp></dd>

      <dt>
        <pre><code>(array (array 2 3)
  (array "foo" "bar"))</code></pre>
      </dt>

      <dd>
        <samp>[[ 2, 3 ], ['foo', 'bar']];</samp>
      </dd>
    </dl>

    <p>The <code>[]</code> macro treats list arguments as quoted,
    making it easy to write nested array literals:</p>

    <dl>
      <dt><code>([] 1 2 (3 4) 5 6)</code></dt>
      <dd><samp>[1, 2, [3, 4], 5, 6];</samp></dd>
    </dl>

    <p>Arrays can also be created with a call to the <code>Array</code>
      function using <code>MAKE-ARRAY</code>.</p>

    <dl>
      <dt><code>(make-array)</code></dt>
      <dd><samp>new Array();</samp></dd>

      <dt><code>(make-array 1 2 3)</code></dt>
      <dd><samp>new Array(1, 2, 3);</samp></dd>

      <dt>
        <pre><code>(make-array
 (make-array 2 3)
 (make-array "foobar" "bratzel bub"))</code></pre>
      </dt>

      <dd>
        <samp>new Array(new Array(2, 3), new Array('foobar', 'bratzel bub'));</samp>
      </dd>
    </dl>

    <p>Array elements can be accessed using <code>AREF</code> or <code>ELT</code>.</p>

    <h2 id="section-arithmetic">Arithmetic and boolean operators</h2>
    <ul>
      <li>(&lt;operator&gt; {<var>argument</var>}*)</li>
      <li>(&lt;single-operator&gt; <var>argument</var>)</li>
    </ul>

    <dl>
      <dt>&lt;operator&gt;</dt>
      <dd>one of <code>*, /, +, -, <, >, <=, >=, =, AND, ASH, EQ, EQL, EQUAL, LOGAND, LOGIOR, LOGXOR, MOD, OR, REM, SETF</code>
      </dd>
      <dt>&lt;single-operator&gt;</dt>
      <dd>one of <code>DECF, INCF, LOGNOT, NOT</code></dd>

      <dt><var>argument</var></dt> <dd>an expression</dd>
    </dl>

    <p>Operator forms are similar to function call forms, but have an
      operator as function name.</p>

    <p>Please note that <code>=</code> is converted to <samp>===</samp> in
      JavaScript. The <code>=</code> Parenscript operator is not the
      assignment operator.</p>

    <dl>
      <dt><code>(* 1 2)</code></dt>
      <dd><samp>1 * 2;</samp></dd>

      <dt><code>(= 1 2)</code></dt>
      <dd><samp>1 === 2;</samp></dd>
    </dl>

    <p>The negation of equality operators are obtained by through <code>NOT</code>. For example:</p>

    <dl>
      <dt><code>(not (eql 1 2))</code></dt>
      <dd><samp>1 !== 2</samp></dd>
    </dl>

    <p>The operators that in CL have variable arity convert into multiple calls
    to the equivalent operators in JavaScript</p>

    <dl>
      <dt><code>(logxor 1 3 7 15)</code></dt>
      <dd><samp>1 ^ 3 ^ 7 ^ 15 </samp></dd>
    </dl>

    <h2 id="section-math">Mathematical functions and constants</h2>
    <ul>
      <li>(<code id="max">MAX</code> {<var>number</var>}*)</li>
      <li>(<code id="min">MIN</code> {<var>number</var>}*)</li>
      <li>(<code id="floor">FLOOR</code> <var>number</var> &amp;optional <var>divisor</var>)</li>
      <li>(<code id="ceiling">CEILING</code> <var>number</var> &amp;optional <var>divisor</var>)</li>
      <li>(<code id="round">ROUND</code> <var>number</var> &amp;optional <var>divisor</var>)</li>
      <li>(<code id="sin">SIN</code> <var>number</var>)</li>
      <li>(<code id="cos">COS</code> <var>number</var>)</li>
      <li>(<code id="tan">TAN</code> <var>number</var>)</li>
      <li>(<code id="asin">ASIN</code> <var>number</var>)</li>
      <li>(<code id="acos">ACOS</code> <var>number</var>)</li>
      <li>(<code id="atan">ATAN</code> <var>number1</var> &amp;optional <var>number2</var>)</li>
      <li>(<code id="sinh">SINH</code> <var>number</var>)</li>
      <li>(<code id="cosh">COSH</code> <var>number</var>)</li>
      <li>(<code id="tanh">TANH</code> <var>number</var>)</li>
      <li>(<code id="asinh">ASINH</code> <var>number</var>)</li>
      <li>(<code id="acosh">ACOSH</code> <var>number</var>)</li>
      <li>(<code id="atanh">ATANH</code> <var>number</var>)</li>
      <li>(<code id="1+">1+</code> <var>number</var>)</li>
      <li>(<code id="1-">1-</code> <var>number</var>)</li>
      <li>(<code id="abs">ABS</code> <var>number</var>)</li>
      <li>(<code id="evenp">EVENP</code> <var>number</var>)</li>
      <li>(<code id="oddp">ODDP</code> <var>number</var>)</li>
      <li>(<code id="exp">EXP</code> <var>number</var>)</li>
      <li>(<code id="expt">EXPT</code> <var>base</var> <var>power</var>)</li>
      <li>(<code id="log">LOG</code> <var>number</var> &amp;optional <var>base</var>)</li>
      <li>(<code id="sqrt">SQRT</code> <var>number</var>)</li>
      <li>(<code id="random">RANDOM</code> &amp;optional <var>limit</var>)</li>

      <li><var id="pi">PI</var></li>
    </ul>

    <p>
      The mathematical functions listed above work mostly like their
      Common Lisp counterparts when called directly, with the
      exception that complex numbers are not supported. However, most
      of them are implemented as macros, and as such cannot be treated
      as first-class functions.
    </p>

    <h2 id="section-blocks">Blocks</h2>
    <ul>
      <li>
        (<code id="block">BLOCK</code> <var>name</var> {<var>expression</var> | <var>statement</var>}*)
      </li>
      <li>
        (<code id="progn">PROGN</code> {<var>statement</var>}*) in statement context
      </li>
      <li>
        (<code>PROGN</code> {<var>expression</var>}*) in expression context
      </li>
      <li>
        (<code id="prog1">PROG1</code> {<var>expression</var> | <var>statement</var>}*)
      </li>
      <li>
        (<code id="prog2">PROG2</code> {<var>expression</var> | <var>statement</var>}*)
      </li>
      <li>
        (<code id="eval-when">EVAL-WHEN</code> {<var>expression</var> | <var>statement</var>}*)
      </li>
    </ul>

    <dl>
      <dt><var>name</var></dt> <dd>Name/tag of the block. A symbol or nil.</dd>
      <dt><var>statement</var></dt> <dd>a form that compiles to a statement</dd>
      <dt><var>expression</var></dt> <dd>a form that compiles to an expression</dd>
    </dl>

    <p>
      The translation of <code>PROGN</code> depends on whether it is
      found in a statement or expression context:
    </p>

    <dl>
      <dt><code>(progn (blorg i) (blafoo i))</code></dt>
      <dd>
<pre><samp>blorg(i);
blafoo(i);</samp></pre>
      </dd>

      <dt><code>(+ i (progn (blorg i) (blafoo i)))</code></dt>
      <dd><samp>i + (blorg(i), blafoo(i));</samp></dd>
    </dl>

    <p>
      The Parenscript <code>EVAL-WHEN</code> special operator has a
      slightly different meaning from the Common Lisp one. The code in
      the <code>EVAL-WHEN</code> special form is assumed to be Common
      Lisp code in <code>:compile-toplevel</code>
      and <code>:load-toplevel</code> situations, and is executed by
      the Parenscript compiler, and is assumed to be Parenscript code
      in the <code>:execute</code> situation, when it is run as
      JavaScript.
    </p>

    <h2 id="section-functions">Functions and multiple values</h2>
    <ul>
      <li>(<code id="defun">DEFUN</code> <var>name</var> <var>lambda-list</var> <var>body</var>)</li>
      <li>(<code id="lambda">LAMBDA</code> <var>lambda-list</var> <var>body</var>)</li>
      <li>(<code id="flet">FLET</code> ({(<var>name</var> <var>lambda-list</var> <var>body</var>)}*) <var>body</var>)</li>
      <li>(<code id="labels">LABELS</code> ({(<var>name</var> <var>lambda-list</var> <var>body</var>)}*) <var>body</var>)</li>
      <li>(<code id="values">VALUES</code> {<var>expression</var>}*)</li>
      <li>(<code id="multiple-value-bind">MULTIPLE-VALUE-BIND</code> ({<var>var</var>}*) <var>expression</var> <var>body</var>)</li>
      <li>(<code id="apply">APPLY</code> <var>function</var> {<var>expression</var>}*)</li>
      <li>(<code id="funcall">FUNCALL</code> <var>function</var> {<var>expression</var>}*)</li>
      <li><var id="this">THIS</var></li>
    </ul>

    <dl>
      <dt><var>expression</var></dt> <dd>a form that compiles to an expression</dd>
      <dt><var>name</var></dt> <dd>a symbol</dd>
      <dt><var>lambda-list</var></dt> <dd>a lambda list</dd>
      <dt><var>body</var></dt> <dd>implicit <code>PROGN</code></dd>
      <dt><var>var</var></dt> <dd>a symbol naming a variable</dd>
      <dt><var>function</var></dt> <dd>an expression that yields a function</dd>
    </dl>

    <p>
      New function definitions can be introduced using all the regular
      Lisp forms
      - <code>DEFUN</code>, <code>LAMBDA</code>, <code>FLET</code>,
      and <code>LABELS</code>. Function lambda lists
      support <code>&amp;optional</code>, <code>&amp;rest</code> and
      <code>&amp;key</code> arguments.
    </p>

    <p>
      The Parenscript multiple value facility passes the first return
      value using the regular JavaScript convention, therefore
      functions returning multiple values can be called by regular
      JavaScript code and <code>MULTIPLE-VALUE-BIND</code> works with
      regular JavaScript functions.
    </p>

    <p>
      To prevent spurious errors
      in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">ECMAScript
      5 strict mode scripts</a>, the backing variable for multiple
      values must be globally declared at the start of strict mode
      scripts:
      <code>(defvar __PS_MV_REG)</code>
    </p>

    <p>
      <code>APPLY</code> is a macro that expands into a call to the
      JavaScript <code>apply</code> method.
    </p>

    <h2 id="section-control-transfer">Control transfer and exceptions</h2>
    <ul>
      <li>
        (<code id="return">RETURN</code> {<var>value</var>}?)
      </li>
      <li>
        (<code id="return-from">RETURN-FROM</code> <var>name</var> {<var>value</var>}?)
      </li>
      <li>
        (<code id="throw">THROW</code> {<var>exp</var>}?)
      </li>
      <li>
        (<code id="try">TRY</code> <var>form</var>
        {(<code id="catch">:CATCH</code> (<var>var</var>) <var>body</var>)}?
        {(<code id="finally">:FINALLY</code> <var>body</var>)}?)
      </li>
      <li>
        (<code id="unwind-protect">UNWIND-PROTECT</code> <var>protected-form</var> <var>cleanup-form</var>)
      </li>
      <li>
        (<code id="ignore-errors">IGNORE-ERRORS</code> <var>body</var>)
      </li>
    </ul>

    <dl>
      <dt><var>value</var></dt> <dd>a statement or expression</dd>
      <dt><var>name</var></dt> <dd>name of block to return from</dd>
      <dt><var>exp</var></dt> <dd>an expression</dd>
      <dt><var>var</var></dt> <dd>variable to which the value of the caught <code>THROW</code> is bound</dd>
      <dt><var>body</var></dt> <dd>implicit <code>PROGN</code></dd>
    </dl>

    <p>
      Parenscript support nested blocks and the <code>RETURN</code>
      and <code>RETURN-FROM</code> special forms.
    </p>

    <dl>
      <dt>
<pre><code>(defun foo (x)
  (progn
    (abc)
    (return-from foo
      (case x
        (1 :a)
        (2 :b)))
    (xyz)))</code></pre>
      </dt>

      <dd>
<pre><samp>function foo(x) {
    abc();
    switch (x) {
    case 1:
        return 'a';
    case 2:
        return 'b';
    };
    return xyz();
};</samp></pre>
      </dd>
    </dl>

    <p>
      Currently, <code>THROW</code> translates directly into the
      JavaScript <samp>throw</samp>, to be used with <code>TRY</code>,
      which is translated to the JavaScript <samp>try</samp>.
    </p>

    <dl>
      <dt>
<pre><code>(try (throw "i")
 (:catch (error)
   (alert (+ "an error happened: " error)))
 (:finally
   (alert "Leaving the try form")))</code></pre>
      </dt>

      <dd>
<pre><samp>try {
       throw 'i';
   } catch (error) {
       alert('an error happened: ' + error);
   } finally {
       alert('Leaving the try form');
   };</samp></pre>
      </dd>
    </dl>

    <h2 id="section-conditionals">Conditionals</h2>
    <ul>
      <li>(<code id="if">IF</code> <var>condition</var> <var>then</var> {<var>else</var>})</li>
      <li>(<code id="when">WHEN</code> <var>condition</var> <var>then</var>)</li>
      <li>(<code id="unless">UNLESS</code> <var>condition</var> <var>then</var>)</li>
      <li>(<code id="cond">COND</code> {<var>clause</var>}*)</li>
      <li>(<code id="case">CASE</code> <var>case-value</var> <var>clause</var>*)</li>
      <li>(<code id="switch">SWITCH</code> <var>case-value</var> <var>clause</var>*)</li>
      <li><code id="break">BREAK</code></li>
    </ul>

    <dl>
      <dt><var>condition</var></dt> <dd>an expression</dd>
      <dt><var>then</var></dt> <dd>a statement in statement context, or an expression in expression context</dd>
      <dt><var>else</var></dt> <dd>a statement in statement context, or an expression in expression context</dd>
      <dt><var>clause</var></dt> <dd>(&lt;<var>value</var>&gt; <var>body</var>) | (<var>default</var> <var>body</var>)</dd>
    </dl>

    <p><code>IF, WHEN, UNLESS</code> and <code>COND</code> work like
    their Lisp counterparts, and are compiled either into statements
    or expressions, depending on the context:</p>

    <dl>
      <dt>
        <code>(cond ((= x 1) (+ x (if (foo y) 2 3))))</code>
      </dt>

      <dd>
<pre><samp>if (x == 1) {
    x + (foo(y) ? 2 : 3);
};</samp></pre>
      </dd>
    </dl>

    <p>
      <code>CASE</code> works similar to its Common Lisp equivalent.
    </p>

    <p>
      An additional form, <code>SWITCH</code>, takes the same syntax
      as <code>CASE</code>, but the individual branches must be
      terminated with the
      symbol <a href="#break"><code>BREAK</code></a>. This allows
      C-style case "fall-throughs" in <code>switch</code> statements:
    </p>

    <dl>
      <dt>
<pre><code>(switch (aref blorg i)
  (1 (alert "If I get here"))
  (2 (alert "I also get here")
     break)
  (default (alert "I always get here")))</code></pre>
      </dt>

      <dd>
<pre><samp>switch (blorg[i]) {
case 1:
    alert('If I get here');
case 2:
    alert('I also get here');
    break;
default:
    alert('I always get here');
};</samp></pre>
      </dd>
    </dl>

    <p>Note that the default case in a <code>SWITCH</code> statement
    must be named <code id="default">DEFAULT</code>.</p>

    <h2 id="section-variables">Variable binding and declaration</h2>
    <ul>
      <li>(<code id="let">LET</code> ({<var>var</var> | (<var>var</var> <var>value</var>)}*) <var>body</var>)</li>
      <li>(<code id="let*">LET*</code> ({<var>var</var> | (<var>var</var> <var>value</var>)}*) <var>body</var>)</li>
      <li>(<code id="defvar">DEFVAR</code> <var>var</var> {<var>value</var>}?)</li>
      <li>(<code id="defparameter">DEFPARAMETER</code> <var>var</var> {<var>value</var>}?)</li>
      <li>(<code id="var">VAR</code> <var>var</var> {<var>value</var>}?)</li>
    </ul>

    <dl>
      <dt><var>var</var></dt> <dd>a symbol</dd>
      <dt><var>value</var></dt> <dd>an expression</dd>
      <dt><var>body</var></dt> <dd>implicit <code>PROGN</code></dd>
      <dt><var>object</var></dt> <dd>an expression evaluating to an object</dd>
    </dl>

    <p>Parenscript provides the <code>LET</code> and <code>LET*</code>
      special forms for creating new variable bindings. Both special
      forms implement lexical scope by renaming the provided variables
      via <a href="#ps-gensym"><code>GENSYM</code></a>, and implement
      dynamic binding
      using <a href="#try"><code>TRY-FINALLY</code></a>.</p>

    <p>Special variables can be declared using
      <code>DEFVAR</code>. Note that the result is undefined
      if <code>DEFVAR</code> does not occur as a top-level form.</p>

    <p>One Parenscript feature that is not part of Common Lisp is the
      lexically-scoped global variable, which is declared using
      the <code>VAR</code> special form. The result is undefined
      if <code>VAR</code> does not occur as a top-level form.</p>

    <p>An example of variable declaration and binding:</p>

    <dl>
      <dt>
<pre><code>(defvar *a* 4)
(var *b* 3)
(lambda ()
  (let ((x 1)
        (*a* 2)
        (*b* 6))
    (let* ((y (+ x 1))
           (x (+ x y)))
      (+ *a* *b* x y))))</code></pre>
      </dt>

      <dd>
<pre><samp>var A = 4;
var B = 3;
function () {
    var x = 1;
    var B = 6;
    var A_TMPSTACK1;
    try {
        A_TMPSTACK1 = A;
        A = 2;
        var y = x + 1;
        var x2 = x + y;
        return A + B + x2 + y;
    } finally {
        A = A_TMPSTACK1;
    };
};</samp></pre>
      </dd>
    </dl>

    <h2 id="section-assignment">Assignment</h2>

    <p>Parenscript assignment is done via the
      standard <code id="setf">SETF</code>, <code id="SETQ">SETQ</code>,
      <code id="PSETF">PSETF</code>, and <code id="PSETQ">PSETQ</code>
      Lisp special forms. Parenscript supports the Common Lisp
      protocol of <code>SETF</code>able places.</p>

    <p>New places can be defined in one of two ways: using
      <code>DEFSETF</code> or using <code>DEFUN</code> with a setf
      function name; both are analogous to their Common Lisp
      counterparts. <code>DEFSETF</code> supports both long and short
      forms, while <code>DEFUN</code> of a setf place generates a
      JavaScript function name with the <samp>__setf_</samp>
      prefix:</p>

    <dl>
      <dt>
        <pre><code>(defun (setf color) (new-color el)
  (setf (@ el style color) new-color))</code></pre>
      </dt>

      <dd>
<pre><samp>function __setf_color(newColor, el) {
    return el.style.color = newColor;
};</samp></pre>
      </dd>

      <dt>
        <code>(setf (color some-div) (+ 23 "em"))</code>
      </dt>

      <dd>
        <pre><samp>var _js2 = someDiv;
var _js1 = 23 + 'em';
__setf_color(_js1, _js2);</samp></pre>
      </dd>
    </dl>

    <p>The following example illustrates how setf places can be used
      to provide a uniform protocol for positioning elements in HTML
      pages:</p>

    <dl>
      <dt>
<pre><code>(defsetf left (el) (offset)
  `(setf (@ ,el style left) ,offset))

(defmacro left (el)
  `(@ ,el offset-left))

(setf (left some-div) (+ 123 "px"))
(left some-div)</code></pre>
      </dt>

      <dd>
<pre><samp>var _js2 = someDiv;
var _js1 = 123 + 'px';
_js2.style.left = _js1;
someDiv.offsetLeft;</samp></pre>
      </dd>
    </dl>

    <h2 id="section-iteration">Iteration</h2>
    <ul>
      <li>(<code id="do">DO</code> ({<var>var</var> | (<var>var</var> {<var>init</var>}? {<var>step</var>}?)}*) (<var>end-test</var> {<var>result</var>}?) <var>body</var>)</li>
      <li>(<code id="do*">DO*</code> ({<var>var</var> | (<var>var</var> {<var>init</var>}? {<var>step</var>}?)}*) (<var>end-test</var> {<var>result</var>}?) <var>body</var>)</li>
      <li>(<code id="dotimes">DOTIMES</code> (<var>var</var> <var>numeric-form</var> {<var>result</var>}?) <var>body</var>)</li>
      <li>(<code id="dolist">DOLIST</code> (<var>var</var> <var>list-form</var> {<var>result</var>}?) <var>body</var>)</li>
      <li>(<code id="for-in">FOR-IN</code> (<var>var</var> <var>object</var>) <var>body</var>)</li>
      <li>(<code id="loop">LOOP</code> {&lt;loop clauses&gt;}*)</li>
    </ul>

    <dl>
      <dt><var>var</var></dt> <dd>a symbol</dd>
      <dt><var>numeric-form</var></dt> <dd>a number yielding expression</dd>
      <dt><var>list-form</var></dt> <dd>an array yielding expression</dd>
      <dt><var>object-form</var></dt>  <dd>an object yielding expression</dd>
      <dt><var>init</var></dt> <dd>an expression</dd>
      <dt><var>step</var></dt> <dd>an expression</dd>
      <dt><var>end-test</var></dt> <dd>an expression</dd>
      <dt><var>result</var></dt> <dd>an expression</dd>
      <dt><var>body</var></dt> <dd>implicit <code>PROGN</code></dd>
    </dl>

    <p>Parenscript comes with a wide array of Common Lisp iteration
    constructs that compile to efficient JavaScript code,
    including a partial implementation of <code>LOOP</code>.</p>

    <h2 id="section-macros">Macros</h2>
    <h3 id="ssection-defining-macros">Defining macros</h3>
    <ul>
      <li>(<code id="defmacro">DEFMACRO</code> <var>name</var> <var>lambda-list</var> <var>macro-body</var>)</li>
      <li>(<code id="defpsmacro">DEFPSMACRO</code> <var>name</var> <var>lambda-list</var> <var>macro-body</var>)</li>
      <li>(<code id="defmacro+ps">DEFMACRO+PS</code> <var>name</var> <var>lambda-list</var> <var>macro-body</var>)</li>
      <li>(<code id="import-macros-from-lisp">IMPORT-MACROS-FROM-LISP</code> {<var>symbol</var>}*)</li>
      <li>(<code id="macrolet">MACROLET</code> ({<var>name</var> <var>lambda-list</var> <var>macro-body</var>}*) <var>body</var>)</li>
    </ul>

    <dl>
      <dt><var>name</var></dt> <dd>a symbol</dd>
      <dt><var>lambda-list</var></dt> <dd>a lambda list</dd>
      <dt><var>macro-body</var></dt> <dd>Lisp code evaluating to Parenscript code</dd>
      <dt><var>body</var></dt> <dd>implicit <code>PROGN</code></dd>
      <dt><var>symbol</var></dt> <dd>symbol with a Lisp macro function definition</dd>
    </dl>

    <p>Parenscript macros are like Lisp macros in that they have
    access to the full Lisp language, but different in that they must
    produce Parenscript code. Since Parenscript provides a large
    subset of Common Lisp, many Lisp macros already produce valid
    Parenscript code, and vice-versa. Parenscript provides several
    different ways to define new macros, and to use already existing
    Common Lisp macros.</p>

    <p><code>DEFMACRO</code> and <code>MACROLET</code> can be used to
    define new macros in Parenscript code. Note that macros defined
    this way are defined in a null lexical environment (ex
    - <code>(let ((x 1)) (defmacro baz (y) `(+ ,y ,x)))</code> will
    not work), since the surrounding Parenscript code is just
    translated to JavaScript and not actually evaluated.</p>

    <p><code>DEFPSMACRO</code> is a Lisp form (not a Parenscript one!)
    that can be used by Lisp code to define Parenscript macros without
    calling the Parenscript compiler.</p>

    <p>The representation of Parenscript macro functions is the same
      as that of Common Lisp, and in fact Parenscript can use already
      defined macros this way.

    <p><code>DEFMACRO+PS</code> defines two macros with the same name
      and expansion, one in Parenscript and one in
      Lisp. <code>DEFMACRO+PS</code> is used when the full
      macro-expansion of the Lisp macro yields code that cannot be used
      by Parenscript.</p>

    <p>Parenscript also supports the use of macros defined in the
      underlying Lisp environment. Existing Lisp macros can be
      imported into the Parenscript macro environment
      by <code>IMPORT-MACROS-FROM-LISP</code>. This functionality
      enables code sharing between Parenscript and Lisp, and is useful
      in debugging since the full power of Lisp macro-expanders,
      editors and other supporting facilities can be used. However, it
      is important to note that the macro-expansion of Lisp macros and
      Parenscript macros takes place in their own respective
      environments, and many Lisp macros (especially those provided by
      the Lisp implementation) expand into code that is not usable by
      Parenscript. To make it easy for users to take advantage of
      these features, two additional macro definition facilities are
      provided by Parenscript: </p>

    <h3 id="ssection-symbol-macros">Symbol macros</h3>

    <ul>
      <li>(<code id="define-ps-symbol-macro">DEFINE-PS-SYMBOL-MACRO</code> <var>symbol</var> <var>expansion</var>)</li>
      <li>(<code id="symbol-macrolet">SYMBOL-MACROLET</code> ({<var>name</var> <var>macro-body</var>}*) <var>body</var>)</li>
    </ul>

    <p>Symbol macros can be introduced
      using <code>SYMBOL-MACROLET</code> or defined in Lisp
      with <code>DEFINE-PS-SYMBOL-MACRO</code>. For example, the
      Parenscript
      <code>WITH-SLOTS</code> is implemented using symbol macros:</p>

    <dl>
      <dt>
    <pre><code>(defpsmacro with-slots (slots object &amp;rest body)
  `(symbol-macrolet ,(mapcar #'(lambda (slot)
                                 `(,slot '(getprop ,object ',slot)))
                             slots)
    ,@body))</code></pre>
      </dt>
    </dl>

    <h3 id="ssection-gensym">Gensym</h3>
    <ul>
      <li>(<code id="ps-gensym">PS-GENSYM</code> {<var>string</var>})</li>
      <li>(<code id="with-ps-gensyms">WITH-PS-GENSYMS</code> <var>symbols</var> &amp;body <var>body</var>)</li>
      <li>(<code id="ps-once-only">PS-ONCE-ONLY</code> (&amp;rest <var>vars</var>) &amp;body <var>body</var>)</li>
      <li>(<code id="maybe-once-only">MAYBE-ONCE-ONLY</code> (&amp;rest <var>vars</var>) &amp;body <var>body</var>)</li>

      <li><var id="*ps-gensym-counter*">*PS-GENSYM-COUNTER*</var></li>
    </ul>

    <p>JavaScript identifier equality is based on string
    representations, as opposed to Common Lisp, where two uninterned
    symbols with the same name are different objects. Therefore
    Parenscript <code>GENSYM</code> depends
    on <var>*PS-GENSYM-COUNTER*</var> values only for generating
    unique identifiers. <var>*PS-GENSYM-COUNTER*</var> does not
    persist and is not guaranteed to be thread-safe, so care should be
    taken to avoid writing var where gensymed identifiers may clash
    (for example, this could happen if you concatenate JS var from PS
    compilers running in two different Lisp images, where the values
    of <var>*PS-GENSYM-COUNTER*</var> overlap).

    <h2 id="section-utilities">Utilities</h2>

    <h3 id="ssection-dom">DOM</h3>
    <ul>
      <li>(<code>INNER-HTML</code> <var>el</var>)</li>
      <li>(<code>URI-ENCODE</code> <var>el</var>)</li>
      <li>(<code>ATTRIBUTE</code> <var>el</var>)</li>
      <li>(<code>OFFSET</code> <var>compass</var> <var>el</var>)</li>
      <li>(<code>SCROLL</code> <var>compass</var> <var>el</var>)</li>
      <li>(<code>INNER</code> <var>wh</var> <var>el</var>)</li>
      <li>(<code>CLIENT</code> <var>wh</var> <var>el</var>)</li>
    </ul>

    <dl>
      <dt><var>el</var></dt> <dd>an expression that yields a DOM element</dd>
      <dt><var>compass</var></dt> <dd>one of <code>:TOP, :LEFT, :HEIGHT, :WIDTH, :BOTTOM, :RIGHT</code></dd>
      <dt><var>wh</var></dt> <dd>one of <code>:WIDTH, :HEIGHT</code></dd>
    </dl>

    <h3 id="ssection-html-gen">HTML generation</h3>
    <ul>
      <li>(<code id="ps-html">PS-HTML</code> <var>html-expression</var>)</li>
      <li>(<code id="who-ps-html">WHO-PS-HTML</code> <var>html-expression</var>)</li>
      <li><var id="*ps-html-empty-tag-aware-p*">*PS-HTML-EMPTY-TAG-AWARE-P*</var></li>
      <li><var id="*ps-html-mode*">*PS-HTML-MODE*</var></li>
    </ul>

    <p>Parenscript comes with two HTML markup generation facilities
      that produce Parenscript code - <code>PS-HTML</code>
      and <code>WHO-PS-HTML</code>. The former
      accepts <a href="https://franz.com/support/documentation/current/doc/aserve/htmlgen.html">LHTML</a>
      style markup; the latter
      accepts <a href="https://edicl.github.io/cl-who/">CL-WHO</a>
      style markup.</p>

    <p><var>*PS-HTML-EMPTY-TAG-AWARE-P*</var>
      and <var>*PS-HTML-MODE*</var> control how tags are closed when an
      HTML element has no
      content. When <var>*PS-HTML-EMPTY-TAG-AWARE-P*</var> is <code>nil</code>, all
      tags are fully closed (ex - <code>:BR</code> is translated
      as <samp>&lt;BR&gt;&lt;/BR&gt;</samp>). When <var>*PS-HTML-EMPTY-TAG-AWARE-P*</var>
      has a non-nil value and <var>*PS-HTML-MODE*</var>
      is <code>:SGML</code>, tags such as <code>BR</code> are output without
      being closed. When <var>*PS-HTML-MODE*</var> is <code>:XML</code>,
      XML-style closing tags are used (ex - <code>:BR</code> is
      translated as <samp>&lt;BR /&gt;</samp>).</p>

    <dl>
      <dt><code>(ps-html ((:a :href "foobar") "blorg"))</code></dt>
      <dd><samp>'&lt;A HREF=\"foobar\"&gt;blorg&lt;/A&gt;';</samp></dd>

      <dt><code>(who-ps-html (:a :href (generate-a-link) "blorg"))</code></dt>
      <dd><samp>'&lt;A HREF=\"' + generateALink() + '\"&gt;blorg&lt;/A&gt;';</samp></dd>
    </dl>

    <p>The Parenscript compiler can be recursively called in an HTML
      expression:</p>

    <dl>
      <dt>
<pre><code>((@ document write)
  (ps-html ((:a :href "#"
                :onclick (ps-inline (transport))) "link")))</code></pre>
      </dt>

      <dd><samp>document.write('&lt;A HREF=\"#\" ONCLICK=\"' + ('javascript:' + 'transport()') + '\"&gt;link&lt;/A&gt;');</samp></dd>
    </dl>

    <p>Forms may be used in attribute lists to conditionally generate
      the next attribute. In this example the textarea is sometimes
      disabled.</p>

    <dl>
      <dt>
<pre><code>(let ((disabled nil)
      (authorized t))
   (setf (@ element inner-h-t-m-l)
         (ps-html ((:textarea (or disabled (not authorized)) :disabled "disabled")
                "Edit me"))))</code></pre>
      </dt>

      <dd>
<pre><samp>var disabled = null;
   var authorized = true;
   element.innerHTML =
   '&lt;TEXTAREA'
   + (disabled || !authorized ? ' DISABLED=\"' + 'disabled' + '\"' : '')
   + '&gt;Edit me&lt;/TEXTAREA&gt;';</samp></pre>
      </dd>
    </dl>

    <h2 id="section-runtime-library">Run-time library</h2>
    <ul>
      <li>(<code id="member">MEMBER</code> <var>object</var> <var>array</var>)</li>
      <li>(<code id="map">MAP</code> <var>function</var> <var>array</var>)</li>
      <li>(<code id="mapcar">MAPCAR</code> <var>function</var> {<var>array</var>}*)</li>
      <li>(<code id="reduce">REDUCE</code> <var>function</var> <var>array</var> <var>object</var>)</li>
      <li>(<code id="map-into">MAP-INTO</code> <var>function</var> <var>array</var>)</li>
      <li>(<code id="set-difference">SET-DIFFERENCE</code> <var>array1</var> <var>array2</var>)</li>
      <li><var id="*ps-lisp-library*">*PS-LISP-LIBRARY*</var></li>
    </ul>

    <p>All the Parenscript constructs presented so far have been free
      of any run-time dependencies. Parenscript also comes with a library
      of useful predefined functions that can be added to your
      project. These functions are kept as Parenscript code in
      the <var>*PS-LISP-LIBRARY*</var> special variable.</p>

    <p><code>MAP</code> differs from its Common Lisp counterpart by
      virtue of being a <code>MAPCAR</code> that only accepts a single
      sequence to map over. <code>MAP-INTO</code> is
      like <code>MAP</code> but replaces the contents of the given
      array in-place.</p>

    <h2 id="section-slime-integration">SLIME integration</h2>

    <p>The <kbd>extras</kbd> folder in the Parenscript distribution
      contains <kbd>js-expander.el</kbd>, which when loaded in Emacs
      with SLIME adds the ability to quickly see the translation of
      any Lisp form in JavaScript, and works much like the Slime '<kbd>C-c
        M-m</kbd>' macro-expansion feature.</p>

    <p>'<kbd>C-c j</kbd>' (<a href="#ps"><code>PS</code></a>) or
      '<kbd>C-c d</kbd>' (<a href="#ps-doc"><code>PS-DOC</code></a>)
      at a Parenscript expression in a <code>slime-mode</code> buffer
      will bring up a buffer with the resulting JavaScript code. Note
      that the extension does not work
      in <code>slime-repl-mode</code>, which is intentional.</p>

    <p><kbd>extras/swank-parenscript.lisp</kbd> shows how to add support
    to SLIME for printing hints about Parenscript-defined macro and
    function argument lists to the Emacs minibuffer, like SLIME
    already does for Common Lisp functions and macros.</p>

    <p style="font-size:xx-small;float:right;">Last updated: 2020-04-11</p>
  </body>
</html>
